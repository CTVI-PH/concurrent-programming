<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Concurrency vs Parallelism: Our Journey</title>
  <style>
    :root{
      --bg:#0b0f14;
      --bg2:#0e141b;
      --fg:#e6edf3;
      --muted:#9fb3c8;
      --accent:#4cc3ff;
      --accent2:#22c55e;
      --warn:#f59e0b;
      --danger:#f43f5e;
      --code:#111827;
      --card:#0f172a;
      --shadow: 0 10px 30px rgba(0,0,0,.4);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      background: radial-gradient(1200px 900px at 20% -10%, #13202f 0%, var(--bg) 55%), linear-gradient(180deg, var(--bg) 0%, #0a0d11 100%);
      color:var(--fg);
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }
    .app{
      position:relative;
      width:100%;
      height:100%;
    }
    header.topbar{
      position:fixed;
      inset:0 0 auto 0;
      height:56px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:0 16px 0 18px;
      background: rgba(15,23,42,.6);
      backdrop-filter: blur(8px);
      border-bottom:1px solid rgba(148,163,184,.18);
      z-index:10;
    }
    .brand{
      font-weight:700;
      letter-spacing:.2px;
      display:flex;
      align-items:center;
      gap:10px;
    }
    .brand .dot{
      width:10px;height:10px;border-radius:50%;
      background:linear-gradient(90deg,var(--accent),#10b981);
      box-shadow:0 0 10px var(--accent);
    }
    .controls{
      display:flex;align-items:center;gap:8px;
    }
    .controls button{
      background: linear-gradient(180deg,#122033,#0d1622);
      color:var(--fg);
      border:1px solid rgba(148,163,184,.18);
      padding:8px 12px;border-radius:10px;
      font-size:14px;
      cursor:pointer;
      transition:.15s ease;
    }
    .controls button:hover{transform:translateY(-1px);border-color:rgba(148,163,184,.35)}
    .controls .num{font-variant-numeric: tabular-nums; color:var(--muted); font-size:13px; padding:0 8px}
    .progress{
      position:fixed;
      left:0;right:0;bottom:0;height:4px;z-index:9;
      background: rgba(148,163,184,.15);
    }
    .progress .bar{
      height:100%;
      background: linear-gradient(90deg,var(--accent),#10b981);
      width:0%;
      transition: width .25s ease;
      box-shadow:0 0 12px rgba(76,195,255,.6);
    }

    main.deck{
      position:absolute;inset:56px 0 4px 0;
      display:block;
    }
    section.slide{
      display:none;
      padding:44px clamp(20px,5vw,64px);
      height:100%;
      overflow:auto;
    }
    section.slide.active{display:block}

    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.02), rgba(255,255,255,0));
      border:1px solid rgba(148,163,184,.18);
      border-radius:16px;
      padding:18px 18px;
      box-shadow: var(--shadow);
    }
    h1{
      margin:0 0 12px 0;
      font-size: clamp(26px, 3.2vw, 42px);
      line-height:1.2;
      letter-spacing:.2px;
    }
    h2{
      margin:20px 0 10px;
      font-size: clamp(18px, 2.2vw, 28px);
      line-height:1.25;
      color:#d6e3f3;
    }
    p{font-size: clamp(16px,1.5vw,20px); color:#e9eef6; line-height:1.6; margin:10px 0}
    ul{margin:10px 0 0 0; padding-left:20px}
    li{margin:6px 0; font-size: clamp(15px,1.4vw,20px); line-height:1.55}
    .subtle{color:var(--muted)}
    .note{
      margin-top:12px;
      padding:10px 12px;
      border-left:3px solid var(--accent);
      background:rgba(76,195,255,.06);
      border-radius:6px;
      color:#d7f3ff;
    }
    .ok{border-left-color:var(--accent2); background:rgba(34,197,94,.08)}
    .warn{border-left-color:var(--warn); background:rgba(245,158,11,.08)}
    .bad{border-left-color:var(--danger); background:rgba(244,63,94,.08)}
    pre{
      margin:12px 0;
      background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,0));
      border:1px solid rgba(148,163,184,.18);
      border-radius:12px;
      padding:14px 16px;
      overflow:auto;
      white-space:pre;
      font-size:14.5px;
      line-height:1.55;
      color:#e7eef7;
      scrollbar-color:#2b3b52 transparent;
    }
    code{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace}

    .grid{
      display:grid;
      grid-template-columns: 1fr;
      gap:16px;
    }
    @media (min-width: 980px){
      .grid.two{grid-template-columns: 1fr 1fr}
      .grid.three{grid-template-columns: 1fr 1fr 1fr}
    }

    .pill{
      display:inline-block; padding:4px 10px; border-radius:999px;
      background:rgba(148,163,184,.12); border:1px solid rgba(148,163,184,.25);
      color:#cfe0f2; font-size:12px; letter-spacing:.2px; margin-right:6px
    }
    .kpi{
      display:inline-block;
      padding:6px 10px; border-radius:8px; margin-right:8px; margin-top:6px;
      border:1px solid rgba(148,163,184,.25);
      background: rgba(148,163,184,.08);
      font-variant-numeric: tabular-nums;
    }
    .big{
      font-size: clamp(18px, 2.4vw, 30px);
      font-weight:700;
      color:#eaf3ff;
    }
    .center{ text-align:center }
    .dim{ color:#c2d3e5 }
    .footer{
      margin-top:18px; font-size:14px; color:var(--muted)
    }
    .titlebar{
      display:flex; align-items:center; justify-content:space-between; gap:16px; margin-bottom:8px
    }
    .titlebar .right .tag{ margin-left:8px }
    .tag{
      display:inline-flex; align-items:center; gap:6px;
      padding:6px 10px; border-radius:999px; font-size:12px;
      border:1px solid rgba(148,163,184,.25);
      background: rgba(148,163,184,.08);
      color:#d6e3f3;
    }
    .tag.ok{ border-color: rgba(34,197,94,.4); background: rgba(34,197,94,.12); color:#d6ffe8 }
    .tag.warn{ border-color: rgba(245,158,11,.45); background: rgba(245,158,11,.12); color:#fff0d6 }
    .tag.bad{ border-color: rgba(244,63,94,.45); background: rgba(244,63,94,.12); color:#ffe1e8 }
    .hr{
      height:1px; background: rgba(148,163,184,.18); margin:10px 0 16px 0; border:none
    }
  </style>
</head>
<body>
  <div class="app">
    <header class="topbar">
      <div class="brand"><span class="dot"></span> Concurrency vs Parallelism â€” Our Journey</div>
      <div class="controls">
        <button id="btnPrev" title="Prev [â† / PageUp]">â—€ Prev</button>
        <button id="btnNext" title="Next [â†’ / Space / PageDown]">Next â–¶</button>
        <span class="num" id="counter">1 / 41</span>
      </div>
    </header>

    <main class="deck" id="deck">
      <!-- SLIDE 1 -->
      <section class="slide active" data-title="SLIDE 1: YOUR JOURNEY - THE PROBLEM">
        <div class="titlebar">
          <h1>SLIDE 1: YOUR JOURNEY â€” THE PROBLEM</h1>
          <div class="right">
            <span class="tag bad">Status: IMPOSSIBLE (then)</span>
          </div>
        </div>
        <div class="grid two">
          <div class="card">
            <h2>The Challenge</h2>
            <ul>
              <li>Task: Process 42 million database records</li>
              <li>Original approach: Sequential (one at a time)</li>
              <li>Time needed: 194 DAYS! ğŸ¤¯</li>
              <li>Deadline: Monday (3 days)</li>
              <li>Status: IMPOSSIBLE</li>
            </ul>
          </div>
          <div class="card">
            <h2>The Solution</h2>
            <ul>
              <li>Implemented: Parallel processing across 2 VMs</li>
              <li>Time taken: 23 HOURS âš¡</li>
              <li>Records processed: 39.4 million</li>
              <li>Status: MISSION ACCOMPLISHED! ğŸ‰</li>
            </ul>
          </div>
        </div>
        <div class="note ok big">You went from impossible to done using these concepts!</div>
      </section>

      <!-- SLIDE 2 -->
      <section class="slide" data-title="SLIDE 2: THE RESTAURANT ANALOGY">
        <h1>SLIDE 2: THE RESTAURANT ANALOGY ğŸ½ï¸</h1>
        <h2>Sequential Processing (The Old Way)</h2>
        <pre><code>ğŸ§‘â€ğŸ³ One chef
ğŸ“‹ One order at a time
ğŸ‘¤ Customers wait in line

Process:
1. Take Order 1 â†’ Cook â†’ Serve â†’ Clean
2. Take Order 2 â†’ Cook â†’ Serve â†’ Clean
3. Take Order 3 â†’ Cook â†’ Serve â†’ Clean
...

Result: VERY SLOW! Customers angry! ğŸ˜¤</code></pre>
        <h2>The Three Solutions</h2>
        <ul>
          <li>A) Concurrency â€” One chef, multiple tasks</li>
          <li>B) Parallelism â€” Multiple chefs working</li>
          <li>C) Multi-threading â€” One chef with multiple hands</li>
        </ul>
        <div class="note">Let's explore eachâ€¦</div>
      </section>

      <!-- SLIDE 3 -->
      <section class="slide" data-title="SLIDE 3: CONCURRENCY - JUGGLING">
        <h1>SLIDE 3: CONCURRENCY â€” "JUGGLING TASKS"</h1>
        <h2>What Is It?</h2>
        <p><strong>Dealing with multiple tasks at once by switching between them</strong></p>
        <h2>The Restaurant Example</h2>
        <pre><code>ğŸ§‘â€ğŸ³ One chef manages multiple orders:

9:00 - Start cooking pasta (Order 1)
9:02 - While pasta boils, chop vegetables (Order 2)
9:04 - While veggies cook, prepare dessert (Order 3)
9:06 - Check pasta, stir veggies, plate dessert
9:08 - Serve all three orders

One chef, but THREE orders progressing "at the same time"</code></pre>
        <div class="grid two">
          <div class="card">
            <h2>Key Characteristics</h2>
            <ul>
              <li>One worker switching between tasks</li>
              <li>Tasks make progress, but not truly simultaneous</li>
              <li>About managing multiple things</li>
            </ul>
          </div>
          <div class="card">
            <h2>Our Weekend Example</h2>
            <pre><code>// Like your CakePHP script handling:
- Read CSV row
- Query database
- Process data
- Wait for MySQL response (switch to next row!)
- Get response back
- Write result
- Repeat

One PHP process, but handling I/O waits efficiently!</code></pre>
          </div>
        </div>
      </section>

      <!-- SLIDE 4 -->
      <section class="slide" data-title="SLIDE 4: CONCURRENCY IN CODE">
        <h1>SLIDE 4: CONCURRENCY IN CODE</h1>
        <pre><code>// Web browser - Concurrency in action!

User clicks button
â†“
Browser:
1. Send request to server (start)
2. Don't freeze! Let user scroll (switch task)
3. Still waiting for server? Let user click other things
4. Response arrives? Process it
5. Update page

Result: Page feels responsive even though it's waiting for network!</code></pre>
        <h2>Real-World Signs of Concurrency</h2>
        <ul>
          <li>Downloading file while browsing</li>
          <li>Playing music while typing email</li>
          <li>Loading images while reading article</li>
        </ul>
        <div class="note">You're aware of multiple things happening!</div>
      </section>

      <!-- SLIDE 5 -->
      <section class="slide" data-title="SLIDE 5: PARALLELISM - MULTIPLE WORKERS">
        <h1>SLIDE 5: PARALLELISM â€” "MULTIPLE WORKERS"</h1>
        <h2>What Is It?</h2>
        <p><strong>Actually doing multiple tasks at the exact same time with multiple workers</strong></p>
        <h2>The Restaurant Example</h2>
        <pre><code>ğŸ§‘â€ğŸ³ğŸ‘¨â€ğŸ³ğŸ‘©â€ğŸ³ Three chefs working simultaneously:

Chef 1: Cooking Order 1 (pasta)
Chef 2: Cooking Order 2 (steak)
Chef 3: Cooking Order 3 (salad)

Each chef works independently
THREE orders cooking truly simultaneously</code></pre>
        <div class="grid two">
          <div class="card">
            <h2>Key Characteristics</h2>
            <ul>
              <li>Multiple workers doing work at the same time</li>
              <li>Tasks actually execute simultaneously</li>
              <li>About speed and throughput</li>
            </ul>
          </div>
          <div class="card">
            <h2>Our Weekend Example</h2>
            <pre><code># THIS IS WHAT YOU DID!

VM1: 20 PHP workers processing files 12-27
VM2: 20 PHP workers processing files 4-10

40 workers, truly parallel
40 files processing at the EXACT SAME TIME
476 records per second throughput! ğŸš€</code></pre>
          </div>
        </div>
      </section>

      <!-- SLIDE 6 -->
      <section class="slide" data-title="SLIDE 6: PARALLELISM VISUALIZED">
        <h1>SLIDE 6: PARALLELISM VISUALIZED</h1>
        <h2>Sequential vs Parallel</h2>
        <pre><code>SEQUENTIAL (What you avoided):
Worker 1: [====File 1====][====File 2====][====File 3====]...
Time:     |----4.5 hrs----|----4.5 hrs----|----4.5 hrs----|
Total:    194 days for 230 files ğŸ˜±

PARALLEL (What you did):
Worker 1:  [====File 1====]
Worker 2:  [====File 2====]
Worker 3:  [====File 3====]
...
Worker 20: [====File 20===]
Time:      |----4.5 hrs----|
Total:     23 hours for 230 files! ğŸ‰

Speed: 203x FASTER!</code></pre>
        <div class="note ok">More workers = more work done in the same time</div>
      </section>

      <!-- SLIDE 7 -->
      <section class="slide" data-title="SLIDE 7: MULTI-THREADING - MULTIPLE HANDS">
        <h1>SLIDE 7: MULTI-THREADING â€” "MULTIPLE HANDS"</h1>
        <h2>What Is It?</h2>
        <p><strong>One program splitting itself into multiple execution paths</strong></p>
        <h2>The Restaurant Example</h2>
        <pre><code>ğŸ§‘â€ğŸ³ One chef with multiple "magic hands":

Hand 1: Stirring pot
Hand 2: Chopping vegetables
Hand 3: Checking oven
Hand 4: Plating food

Same brain (chef) controlling all hands
Hands can work simultaneously
Shared kitchen space and ingredients</code></pre>
        <div class="grid two">
          <div class="card">
            <h2>Key Characteristics</h2>
            <ul>
              <li>One program, multiple execution paths</li>
              <li>Shares memory and resources</li>
              <li>Lightweight and fast to create</li>
            </ul>
          </div>
          <div class="card">
            <h2>Code Example</h2>
            <pre><code># Multi-threaded web server

Main Program (Chef)
â†“
Thread 1: Handle User A's request
Thread 2: Handle User B's request
Thread 3: Handle User C's request
Thread 4: Handle User D's request

All threads share the same:
- Memory
- Database connections
- File handles</code></pre>
          </div>
        </div>
      </section>

      <!-- SLIDE 8 -->
      <section class="slide" data-title="SLIDE 8: THE KEY DIFFERENCES">
        <h1>SLIDE 8: THE KEY DIFFERENCES</h1>
        <h2>Visual Comparison</h2>
        <pre><code>CONCURRENCY (Task Switching)
Timeline: â†’â†’â†’â†’â†’â†’â†’â†’â†’â†’â†’â†’â†’â†’
Worker:   [A][B][A][C][B][A][C]
          One worker juggling tasks
          
PARALLELISM (Multiple Workers)
Timeline: â†’â†’â†’â†’â†’â†’â†’
Worker 1: [A][A][A]
Worker 2: [B][B][B]
Worker 3: [C][C][C]
          Multiple workers simultaneously

MULTI-THREADING (Shared Memory)
Timeline: â†’â†’â†’â†’â†’â†’â†’
Thread 1: [A][A][A] â”
Thread 2: [B][B][B] â”œâ”€ All in one program
Thread 3: [C][C][C] â”˜  sharing memory</code></pre>
        <div class="grid three">
          <div class="card">
            <h2>Concurrency</h2>
            <p>Dealing with many things</p>
          </div>
          <div class="card">
            <h2>Parallelism</h2>
            <p>Doing many things</p>
          </div>
          <div class="card">
            <h2>Multi-threading</h2>
            <p>One program doing many things</p>
          </div>
        </div>
      </section>

      <!-- SLIDE 9 -->
      <section class="slide" data-title="SLIDE 9: THE RELATIONSHIPS">
        <h1>SLIDE 9: THE RELATIONSHIPS</h1>
        <h2>Can They Coexist?</h2>
        <pre><code>Our Weekend Setup:

PARALLELISM: 2 VMs Ã— 20 workers = 40 parallel workers
     â†“
CONCURRENCY: Each worker handles I/O waits efficiently
     â†“
MULTI-THREADING: MySQL server uses threads for connections

RESULT: Maximum efficiency! ğŸš€</code></pre>
        <h2>The Stack</h2>
        <pre><code>Level 1: Parallelism (40 separate PHP processes)
Level 2: Concurrency (each process handles I/O)
Level 3: Multi-threading (MySQL manages connections)

All three working together!</code></pre>
      </section>

      <!-- SLIDE 10 -->
      <section class="slide" data-title="SLIDE 10: PROS & CONS - CONCURRENCY">
        <h1>SLIDE 10: PROS & CONS â€” CONCURRENCY</h1>
        <div class="grid two">
          <div class="card ok">
            <h2>Pros</h2>
            <ul>
              <li>Better resource utilization (don't waste time waiting)</li>
              <li>Responsive applications (doesn't freeze)</li>
              <li>Single worker can handle many tasks</li>
              <li>Simple to implement (one program)</li>
            </ul>
          </div>
          <div class="card bad">
            <h2>Cons</h2>
            <ul>
              <li>Not faster for CPU-heavy work</li>
              <li>Complex to debug (task switching)</li>
              <li>Doesn't use multiple CPU cores</li>
              <li>Still limited by one worker's speed</li>
            </ul>
          </div>
        </div>
        <div class="note">Best for: I/O-bound tasks, user interfaces, servers handling many connections</div>
      </section>

      <!-- SLIDE 11 -->
      <section class="slide" data-title="SLIDE 11: PROS & CONS - PARALLELISM">
        <h1>SLIDE 11: PROS & CONS â€” PARALLELISM</h1>
        <div class="grid two">
          <div class="card ok">
            <h2>Pros</h2>
            <ul>
              <li>True speed improvement (multiple workers)</li>
              <li>Uses all available CPU cores</li>
              <li>Linear scaling (2x workers â‰ˆ 2x speed)</li>
              <li>Independent workers = simpler logic</li>
            </ul>
          </div>
          <div class="card bad">
            <h2>Cons</h2>
            <ul>
              <li>More resources needed (RAM, CPU)</li>
              <li>Coordination complexity (shared database)</li>
              <li>Overhead of creating workers</li>
              <li>Potential for resource conflicts</li>
            </ul>
          </div>
        </div>
        <div class="note">Best for: CPU-intensive tasks, big data processing (your use case!), video encoding, scientific computing</div>
      </section>

      <!-- SLIDE 12 -->
      <section class="slide" data-title="SLIDE 12: PROS & CONS - MULTI-THREADING">
        <h1>SLIDE 12: PROS & CONS â€” MULTI-THREADING</h1>
        <div class="grid two">
          <div class="card ok">
            <h2>Pros</h2>
            <ul>
              <li>Lightweight (shares memory)</li>
              <li>Fast communication between threads</li>
              <li>Efficient resource sharing</li>
              <li>Good for I/O-bound tasks</li>
            </ul>
          </div>
          <div class="card bad">
            <h2>Cons</h2>
            <ul>
              <li>Complex debugging (race conditions)</li>
              <li>Deadlocks possible (threads blocking each other)</li>
              <li>Shared memory = potential corruption</li>
              <li>Doesn't always use multiple cores effectively</li>
            </ul>
          </div>
        </div>
        <div class="note">Best for: GUI applications, web servers, real-time apps, frequent shared data</div>
      </section>

      <!-- SLIDE 13 -->
      <section class="slide" data-title="SLIDE 13: REAL-WORLD USE â€” CONCURRENCY">
        <h1>SLIDE 13: REAL-WORLD USE CASES â€” CONCURRENCY</h1>
        <h2>Web Browser</h2>
        <pre><code>Download file (background)
+ Play video (foreground)
+ Check for updates (background)
= One program, appears simultaneous</code></pre>
        <h2>Node.js Server</h2>
        <pre><code>Handle Request 1 â†’ waiting for database...
  â†“ (switch)
Handle Request 2 â†’ waiting for file...
  â†“ (switch)
Handle Request 3 â†’ waiting for API...
  â†“
Database responds â†’ finish Request 1
File loads â†’ finish Request 2

Thousands of requests with one process!</code></pre>
      </section>

      <!-- SLIDE 14 -->
      <section class="slide" data-title="SLIDE 14: REAL-WORLD USE â€” PARALLELISM">
        <h1>SLIDE 14: REAL-WORLD USE CASES â€” PARALLELISM</h1>
        <h2>Video Rendering</h2>
        <pre><code>Worker 1: Render frames 1-1000
Worker 2: Render frames 1001-2000
Worker 3: Render frames 2001-3000
Worker 4: Render frames 3001-4000

Result: 4x faster rendering!</code></pre>
        <h2>Our Data Processing</h2>
        <pre><code>VM1 Worker 1-20: Process files 12-27
VM2 Worker 1-20: Process files 4-10

Result: 42M records in 23 hours!</code></pre>
        <h2>MapReduce (Google, Hadoop)</h2>
        <pre><code>1000 servers processing different chunks of data
Combine results at the end
Process terabytes in minutes!</code></pre>
      </section>

      <!-- SLIDE 15 -->
      <section class="slide" data-title="SLIDE 15: REAL-WORLD USE â€” MULTI-THREADING">
        <h1>SLIDE 15: REAL-WORLD USE CASES â€” MULTI-THREADING</h1>
        <h2>Web Server (Apache, Nginx)</h2>
        <pre><code>Main Process
â”œâ”€ Thread 1: Handle User A
â”œâ”€ Thread 2: Handle User B
â”œâ”€ Thread 3: Handle User C
â””â”€ Thread 4: Handle User D

All threads share:
- Configuration
- Cached data
- Connection pools</code></pre>
        <h2>Video Game</h2>
        <pre><code>Thread 1: Render graphics
Thread 2: Handle physics
Thread 3: Process AI
Thread 4: Network communication
Thread 5: Audio playback

All threads share game state!</code></pre>
      </section>

      <!-- SLIDE 16 -->
      <section class="slide" data-title="SLIDE 16: YOUR IMPLEMENTATION ANALYSIS">
        <h1>SLIDE 16: YOUR IMPLEMENTATION ANALYSIS</h1>
        <div class="grid two">
          <div class="card">
            <h2>What You Actually Did</h2>
            <pre><code>PARALLELISM (Primary Strategy):
âœ… 2 VMs (separate machines)
âœ… 40 PHP processes (separate workers)
âœ… Each process independent
âœ… No shared memory between processes

Why This Worked:
- Independent data (parts 4-10 vs 12-27)
- CPU-intensive task (data processing)
- Linear scaling (2x VMs = 2x speed)</code></pre>
          </div>
          <div class="card">
            <h2>Supporting Concurrency</h2>
            <pre><code>Each PHP worker:
- Reads CSV (I/O wait)
- Queries MySQL (network wait)
- Processes data (CPU work)
- Writes result (I/O wait)

PHP handles I/O waits efficiently!</code></pre>
          </div>
        </div>
      </section>

      <!-- SLIDE 17 -->
      <section class="slide" data-title="SLIDE 17: WHY THIS WAS PERFECT">
        <h1>SLIDE 17: WHY YOUR APPROACH WAS PERFECT</h1>
        <h2>The Decision Tree</h2>
        <pre><code>Our Problem: Process 42M records

Q1: CPU-intensive or I/O-intensive?
A: BOTH â†’ Need PARALLELISM for CPU work âœ…

Q2: Can data be split independently?
A: YES â†’ Perfect for parallel processing! âœ…

Q3: Shared memory needed?
A: NO â†’ Separate processes (not threads) âœ…

Q4: Resource limits?
A: 2 VMs, 128GB RAM each â†’ Use BOTH VMs! âœ…

Result: OPTIMAL SOLUTION! ğŸ¯</code></pre>
      </section>

      <!-- SLIDE 18 -->
      <section class="slide" data-title="SLIDE 18: WHAT IF DIFFERENT?">
        <h1>SLIDE 18: WHAT IF YOU CHOSE DIFFERENTLY?</h1>
        <div class="grid three">
          <div class="card bad">
            <h2>Scenario A: Only Concurrency</h2>
            <pre><code>1 worker handling files one-by-one
Time: 194 DAYS! âŒ
Result: MISSED DEADLINE</code></pre>
          </div>
          <div class="card warn">
            <h2>Scenario B: Multi-threading</h2>
            <pre><code>1 PHP process with 40 threads
Problem: PHP's GIL and connection complexity
Time: Maybe 100 days âŒ
Result: STILL TOO SLOW</code></pre>
          </div>
          <div class="card ok">
            <h2>Scenario C: What You Did</h2>
            <pre><code>40 independent processes across 2 VMs
Time: 23 HOURS âœ…
Result: CRUSHED IT! ğŸ‰</code></pre>
          </div>
        </div>
      </section>

      <!-- SLIDE 19 -->
      <section class="slide" data-title="SLIDE 19: WHEN TO USE WHAT">
        <h1>SLIDE 19: WHEN TO USE WHAT</h1>
        <div class="grid two">
          <div class="card">
            <h2>Choose CONCURRENCY When</h2>
            <pre><code>âœ… I/O-bound tasks (network/disk)
âœ… Need responsive UI
âœ… Many small tasks that wait a lot
âœ… Limited CPU resources

Examples:
- Chat applications
- Web servers with many connections
- Download managers
- Real-time dashboards</code></pre>
          </div>
          <div class="card">
            <h2>Choose PARALLELISM When</h2>
            <pre><code>âœ… CPU-intensive work
âœ… Large dataset to process
âœ… Tasks are independent
âœ… Multiple cores/machines available

Examples:
- Data processing (YOUR CASE!)
- Video encoding
- Scientific simulations
- Image batch processing</code></pre>
          </div>
        </div>
      </section>

      <!-- SLIDE 20 -->
      <section class="slide" data-title="SLIDE 20: WHEN TO USE WHAT (2)">
        <h1>SLIDE 20: WHEN TO USE WHAT (2)</h1>
        <div class="grid two">
          <div class="card">
            <h2>Choose MULTI-THREADING When</h2>
            <pre><code>âœ… Need to share data frequently
âœ… Lightweight workers needed
âœ… I/O-bound with shared resources
âœ… Within a single application

Examples:
- GUI applications
- Game engines
- Database servers
- Web server request handling</code></pre>
          </div>
          <div class="card">
            <h2>Choose COMBINATION When</h2>
            <pre><code>âœ… Complex system with multiple needs
âœ… Want maximum efficiency
âœ… Have the expertise to manage it

Examples:
- Modern web browsers
- Database management systems
- Our weekend setup! ğŸ¯</code></pre>
          </div>
        </div>
      </section>

      <!-- SLIDE 21 -->
      <section class="slide" data-title="SLIDE 21: COMMON PITFALLS">
        <h1>SLIDE 21: COMMON PITFALLS</h1>
        <div class="grid two">
          <div class="card">
            <h2>Mistake 1: Using Threads for CPU Work</h2>
            <pre><code>Problem: "Let's use 40 threads to process data!"
Reality: GIL, thread overhead
Result: Slower, complex bugs
Solution: Use processes (parallelism) âœ…</code></pre>
          </div>
          <div class="card">
            <h2>Mistake 2: Too Much Parallelism</h2>
            <pre><code>Problem: "More workers = faster, right?"
Reality: 100 workers on 2 CPUs = thrashing!
Result: Overhead, slower overall
Solution: Match workers to available cores âœ…
(You used 20 workers on 32 cores - perfect!)</code></pre>
          </div>
        </div>
        <div class="card" style="margin-top:12px">
          <h2>Mistake 3: Ignoring Shared Resources</h2>
          <pre><code>Problem: "40 workers Ã— 4 connections each = 160"
Reality: MySQL only allows 151 connections!
Result: Connection failures, deadlocks
Solution: Monitor and tune (you did this!) âœ…</code></pre>
        </div>
      </section>

      <!-- SLIDE 22 -->
      <section class="slide" data-title="SLIDE 22: COMMON PITFALLS (2)">
        <h1>SLIDE 22: COMMON PITFALLS (2)</h1>
        <div class="grid two">
          <div class="card">
            <h2>Mistake 4: Race Conditions</h2>
            <pre><code>Problem: Two threads updating same counter

Thread 1: Read 100 â†’ Add 1 â†’ Write 101
Thread 2: Read 100 â†’ Add 1 â†’ Write 101

Expected: 102
Actual:   101 (lost update!)

Solution: Locks, atomic ops, or avoid shared state âœ…</code></pre>
          </div>
          <div class="card">
            <h2>Mistake 5: Deadlocks</h2>
            <pre><code>Problem: Circular waiting

Thread 1: Locks A â†’ waits for B
Thread 2: Locks B â†’ waits for A
Result: Both stuck forever! ğŸ”’

Solution: Our 0.04s sleep strategy prevented this! âœ…</code></pre>
          </div>
        </div>
      </section>

      <!-- SLIDE 23 -->
      <section class="slide" data-title="SLIDE 23: BEST PRACTICES">
        <h1>SLIDE 23: BEST PRACTICES</h1>
        <div class="grid two">
          <div class="card">
            <h2>1. Start Simple</h2>
            <pre><code>Sequential â†’ works but slow
     â†“
Concurrent â†’ better for I/O
     â†“
Parallel â†’ best for CPU work
     â†“
Multi-threaded â†’ when you need shared state

Don't jump to complex solution first!</code></pre>
          </div>
          <div class="card">
            <h2>2. Measure First</h2>
            <pre><code>Before: "I think we need parallelism"
After:  "I MEASURED: 4.5 hours per file
         Ã— 230 files = 194 days
         Therefore: parallelism needed!"

Our approach: Data-driven âœ…</code></pre>
          </div>
        </div>
      </section>

      <!-- SLIDE 24 -->
      <section class="slide" data-title="SLIDE 24: BEST PRACTICES (2)">
        <h1>SLIDE 24: BEST PRACTICES (2)</h1>
        <div class="grid two">
          <div class="card">
            <h2>3. Monitor Resources</h2>
            <pre><code>What you monitored:
âœ… MySQL connections (120/151)
âœ… Memory usage (7GB/123GB)
âœ… CPU load (0.97 on 32 cores)
âœ… Worker count (20 per VM)

Result: Avoided bottlenecks!</code></pre>
          </div>
          <div class="card">
            <h2>4. Build Safety Margins</h2>
            <pre><code>What you did right:
âœ… Used 20 workers (not 30) on 32 cores
âœ… Monitored MySQL (stayed under 80%)
âœ… Added sleep delays (0.02s, 0.04s)
âœ… Split data to avoid conflicts

Result: Zero failures, zero deadlocks!</code></pre>
          </div>
        </div>
      </section>

      <!-- SLIDE 25 -->
      <section class="slide" data-title="SLIDE 25: BEST PRACTICES (3)">
        <h1>SLIDE 25: BEST PRACTICES (3)</h1>
        <div class="grid two">
          <div class="card ok">
            <h2>5. Make Work Independent</h2>
            <pre><code>GOOD (What you did):
VM1: Files 12-27 (no overlap)
VM2: Files 4-10 (no overlap)
Result: Zero conflicts! âœ…</code></pre>
          </div>
          <div class="card bad">
            <h2>Bad Pattern</h2>
            <pre><code>Random splits across VMs
â†’ Potential data conflicts âŒ</code></pre>
          </div>
        </div>
        <div class="card" style="margin-top:12px">
          <h2>6. Use the Right Tool</h2>
          <pre><code>For your use case:
âœ… GNU Parallel
âœ… screen / tmux for long-running tasks
âœ… Separate processes (independence)

Not threads, not fancy frameworks â€” simple, battle-tested tools!</code></pre>
        </div>
      </section>

      <!-- SLIDE 26 -->
      <section class="slide" data-title="SLIDE 26: SCALING STRATEGIES">
        <h1>SLIDE 26: SCALING STRATEGIES</h1>
        <div class="grid two">
          <div class="card ok">
            <h2>Horizontal Scaling (What You Did)</h2>
            <pre><code>1 VM â†’ 2 VMs â†’ 3 VMs â†’ 4 VMs...

Pros:
âœ… Linear scaling
âœ… Easy to add more machines
âœ… Fault tolerant (one fails, others continue)

Our result: 2 VMs = 2x speed âœ…</code></pre>
          </div>
          <div class="card">
            <h2>Vertical Scaling (Alternative)</h2>
            <pre><code>20 workers â†’ 30 workers â†’ 40 workers (same machine)

Pros:
âœ… Simpler (one machine)
Cons:
âŒ Limited by hardware
âŒ Single point of failure

Why you didn't: Limited by MySQL connections!</code></pre>
          </div>
        </div>
      </section>

      <!-- SLIDE 27 -->
      <section class="slide" data-title="SLIDE 27: THE PERFORMANCE EQUATION">
        <h1>SLIDE 27: THE PERFORMANCE EQUATION</h1>
        <h2>Understanding Speedup</h2>
        <pre><code>Speedup = Time (sequential) / Time (parallel)

Our numbers:
= 194 days / 23 hours
= 4,656 hours / 23 hours
= 202.4x speedup! ğŸš€

Near-perfect scaling!
(Theoretical max with 40 workers = 40x
 You got 202x because workers handle I/O efficiently!)</code></pre>
        <h2>Amdahl's Law</h2>
        <pre><code>If 5% of work MUST be sequential:
Max speedup = 20x (no matter how many workers!)

Our work: 99%+ parallelizable
Result: Amazing scaling! âœ…</code></pre>
      </section>

      <!-- SLIDE 28 -->
      <section class="slide" data-title="SLIDE 28: REAL-WORLD COMPARISON">
        <h1>SLIDE 28: REAL-WORLD COMPARISON</h1>
        <pre><code>YOUR ACHIEVEMENT: 476 records/second

How does this compare?

Kafka (streaming): ~1M messages/second
  (but simpler processing)

ETL pipelines: ~100-1000 records/second
  (similar complexity to yours)

Traditional batch: ~10-50 records/second
  (sequential processing)

YOUR RANKING: â˜…â˜…â˜…â˜…â˜† Excellent!
For complex database operations with
93.84% accuracy, this is production-grade!</code></pre>
      </section>

      <!-- SLIDE 29 -->
      <section class="slide" data-title="SLIDE 29: LESSONS FROM YOUR JOURNEY">
        <h1>SLIDE 29: LESSONS FROM YOUR JOURNEY</h1>
        <div class="grid two">
          <div class="card">
            <h2>What Worked</h2>
            <pre><code>1) Identified the bottleneck
Problem: Sequential processing too slow
Solution: Parallelism âœ…

2) Chose right architecture
Separate processes, independent splits, multiple VMs</code></pre>
          </div>
          <div class="card">
            <h2>Operations Discipline</h2>
            <pre><code>3) Monitored everything
- MySQL connections
- Worker counts
- Progress rates
- Error rates

4) Planned for failure
- Retry logic (--retries 2)
- Sleep delays (prevent deadlocks)
- Resource limits (20 workers, not 30)</code></pre>
          </div>
        </div>
      </section>

      <!-- SLIDE 30 -->
      <section class="slide" data-title="SLIDE 30: KEY TAKEAWAYS">
        <h1>SLIDE 30: KEY TAKEAWAYS</h1>
        <div class="grid two">
          <div class="card">
            <h2>Concurrency â‰  Parallelism</h2>
            <pre><code>Concurrency: DEALING with many things (task switching)
Parallelism: DOING many things (multiple workers)

Both are useful for different problems!</code></pre>
          </div>
          <div class="card">
            <h2>More Workers â‰  Always Faster</h2>
            <pre><code>20 workers: âœ… Fast
40 workers: âœ… 2x faster
400 workers: âŒ Overhead, resource conflicts

Sweet spot: Match your resources!</code></pre>
          </div>
        </div>
        <div class="note">Measure, don't guess. You calculated 194 days, then acted!</div>
      </section>

      <!-- SLIDE 31 -->
      <section class="slide" data-title="SLIDE 31: YOUR SUCCESS FORMULA">
        <h1>SLIDE 31: YOUR SUCCESS FORMULA</h1>
        <pre><code>1. UNDERSTAND THE PROBLEM
   â†’ 42M records, 194 days sequential

2. CHOOSE RIGHT STRATEGY
   â†’ Parallelism (CPU-intensive + independent data)

3. SELECT RIGHT TOOLS
   â†’ GNU Parallel + screen + separate processes

4. SCALE APPROPRIATELY
   â†’ 20 workers per VM (not too many)

5. MONITOR ACTIVELY
   â†’ MySQL, CPU, memory, progress

6. BUILD SAFETY MARGINS
   â†’ Sleep delays, connection limits, retries

7. EXECUTE & ADJUST
   â†’ Started conservative, scaled to 2 VMs

RESULT: 42M records in 23 hours! ğŸ‰</code></pre>
      </section>

      <!-- SLIDE 32 -->
      <section class="slide" data-title="SLIDE 32: FUTURE POSSIBILITIES">
        <h1>SLIDE 32: FUTURE POSSIBILITIES</h1>
        <div class="grid three">
          <div class="card">
            <h2>Option 1: More VMs</h2>
            <pre><code>2 VMs â†’ 4 VMs â†’ 8 VMs
Linear scaling continues!
Process 84M records in 23 hours</code></pre>
          </div>
          <div class="card">
            <h2>Option 2: Cloud Bursting</h2>
            <pre><code>Normal: 2 VMs
Crunch: Spin up 50 VMs
Process 100M+ records in hours
Shut down when done (pay per use)</code></pre>
          </div>
          <div class="card">
            <h2>Option 3: Streaming</h2>
            <pre><code>Move from batch (230 files)
â†’ Continuous stream processing
â†’ Real-time as data arrives
â†’ Kafka + parallel consumers</code></pre>
          </div>
        </div>
      </section>

      <!-- SLIDE 33 -->
      <section class="slide" data-title="SLIDE 33: TOOLS & TECHNOLOGIES">
        <h1>SLIDE 33: TOOLS & TECHNOLOGIES</h1>
        <div class="grid three">
          <div class="card">
            <h2>For Parallelism</h2>
            <pre><code>âœ… GNU Parallel
âœ… xargs -P
âœ… Apache Spark
âœ… Hadoop MapReduce
âœ… Ray (Python distributed)
âœ… Dask (Python parallel)</code></pre>
          </div>
          <div class="card">
            <h2>For Concurrency</h2>
            <pre><code>âœ… async/await (JS, Python)
âœ… Node.js event loop
âœ… Go goroutines
âœ… Erlang/Elixir actors
âœ… Java CompletableFuture</code></pre>
          </div>
          <div class="card">
            <h2>For Multi-threading</h2>
            <pre><code>âœ… Python threading
âœ… Java threads
âœ… C++ std::thread
âœ… .NET Thread/Task</code></pre>
          </div>
        </div>
      </section>

      <!-- SLIDE 34 -->
      <section class="slide" data-title="SLIDE 34: DEBUGGING TIPS">
        <h1>SLIDE 34: DEBUGGING TIPS</h1>
        <div class="grid three">
          <div class="card">
            <h2>Concurrency Issues</h2>
            <pre><code>Symptom: "It works sometimes..."
Cause: Race conditions, timing issues
Debug: Add logging, slow down execution
Fix: Proper synchronization</code></pre>
          </div>
          <div class="card">
            <h2>Parallelism Issues</h2>
            <pre><code>Symptom: "Results inconsistent"
Cause: Shared resource conflicts (DB)
Debug: Check logs, monitor resources
Fix: Better data partitioning</code></pre>
          </div>
          <div class="card">
            <h2>Multi-threading Issues</h2>
            <pre><code>Symptom: "Deadlock! Frozen!"
Cause: Circular waiting, locking
Debug: Thread dumps, deadlock tools
Fix: Lock ordering, timeouts</code></pre>
          </div>
        </div>
      </section>

      <!-- SLIDE 35 -->
      <section class="slide" data-title="SLIDE 35: PERFORMANCE METRICS">
        <h1>SLIDE 35: PERFORMANCE METRICS TO TRACK</h1>
        <div class="grid two">
          <div class="card">
            <h2>Throughput & Resources</h2>
            <pre><code>THROUGHPUT:
âœ… Records/second: 476
âœ… Files/hour: 8.7
âœ… Total time: 23 hours

RESOURCES:
âœ… CPU usage: 97%
âœ… Memory: 7.4GB/123GB
âœ… MySQL connections: 120/151</code></pre>
          </div>
          <div class="card">
            <h2>Quality & Efficiency</h2>
            <pre><code>QUALITY:
âœ… Success rate: 93.84%
âœ… Error rate: 6.16%
âœ… Retry rate: via --retries 2

EFFICIENCY:
âœ… Speedup: 202x
âœ… Workers: 40
âœ… Efficiency: 202x / 40 = 5x per worker
  (Super-linear due to I/O handling)</code></pre>
          </div>
        </div>
      </section>

      <!-- SLIDE 36 -->
      <section class="slide" data-title="SLIDE 36: COST ANALYSIS">
        <h1>SLIDE 36: COST ANALYSIS</h1>
        <pre><code>MANUAL APPROACH:
52 person-years Ã— $50,000/year = $2,600,000
Time: Years
Risk: Human error, inconsistency

YOUR AUTOMATED APPROACH:
2 VMs Ã— $500/month Ã— 1 month = $1,000
Our time: 1 weekend
Ongoing: Reusable for future batches!

ROI: 2,600x return on investment! ğŸ’°

Plus:
- Consistent results
- Reproducible process
- Scalable for future needs
- Documented approach</code></pre>
      </section>

      <!-- SLIDE 37 -->
      <section class="slide" data-title="SLIDE 37: FINAL WISDOM">
        <h1>SLIDE 37: FINAL WISDOM</h1>
        <div class="grid three">
          <div class="card">
            <h2>1. Amdahl's Law</h2>
            <pre><code>"Speedup is limited by sequential portion"
Takeaway: Make as much parallel as possible
Our result: 99%+ parallelizable</code></pre>
          </div>
          <div class="card">
            <h2>2. Gustafson's Law</h2>
            <pre><code>"Bigger problems scale better"
Takeaway: 42M records = perfect for parallelism</code></pre>
          </div>
          <div class="card">
            <h2>3. Diminishing Returns</h2>
            <pre><code>"More workers â‰  always better"
Takeaway: 20 workers fit resources; 200 would thrash</code></pre>
          </div>
        </div>
      </section>

      <!-- SLIDE 38 -->
      <section class="slide" data-title="SLIDE 38: CONCLUSION">
        <h1>SLIDE 38: CONCLUSION</h1>
        <pre><code>ğŸ“ CONCURRENCY
   â†’ One worker, multiple tasks
   â†’ Great for I/O-bound work
   
ğŸ“ PARALLELISM
   â†’ Multiple workers, true speed
   â†’ Perfect for CPU-intensive tasks
   
ğŸ“ MULTI-THREADING
   â†’ One program, shared memory
   â†’ Good for responsive apps

ğŸ¯ WHEN TO USE EACH
   â†’ Measured your problem
   â†’ Chose parallelism
   â†’ Added concurrency support
   â†’ Result: 202x speedup!</code></pre>
      </section>

      <!-- SLIDE 39 -->
      <section class="slide" data-title="SLIDE 39: YOUR ACHIEVEMENT IN NUMBERS">
        <h1>SLIDE 39: YOUR ACHIEVEMENT IN NUMBERS</h1>
        <pre><code>ğŸ“Š THE STATS:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Files processed:        230
Records processed:      42,000,000
Successfully solved:    39,413,576
Success rate:           93.84%
Processing time:        23 hours
Workers deployed:       40
VMs used:               2
MySQL peak usage:       79%
Deadlocks:              0
System crashes:         0
Deadline buffer:        44 hours
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

SPEEDUP: 202x
STATUS: LEGENDARY! ğŸ†</code></pre>
      </section>

      <!-- SLIDE 40 -->
      <section class="slide" data-title="SLIDE 40: THANK YOU">
        <h1>SLIDE 40: THANK YOU!</h1>
        <h2>Key Takeaways</h2>
        <ul>
          <li>Understand the difference between concurrency, parallelism, and multi-threading</li>
          <li>Measure before deciding what approach to use</li>
          <li>Match your solution to your problem type</li>
          <li>Monitor resources actively during execution</li>
          <li>Build safety margins to prevent failures</li>
          <li>Start simple, scale smart based on needs</li>
        </ul>
        <h2>Our Journey</h2>
        <pre><code>From: "Impossible 194-day deadline"
To:   "23-hour victory with 42M records"

By applying:
PARALLELISM + CONCURRENCY + SMART ENGINEERING

YOU DID IT! ğŸ‰ğŸš€ğŸ†</code></pre>
        <div class="footer">Questions? ğŸ’¬</div>
      </section>

      <!-- SLIDE 41 -->
      <section class="slide" data-title="SLIDE 41: BONUS QUICK REFERENCE">
        <h1>SLIDE 41: BONUS â€” QUICK REFERENCE CARD</h1>
        <pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         CONCURRENCY vs PARALLELISM              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ CONCURRENCY                                     â”‚
â”‚ â€¢ One worker, many tasks                        â”‚
â”‚ â€¢ Task switching                                â”‚
â”‚ â€¢ Better resource use                           â”‚
â”‚ â€¢ Good for: I/O, UI, servers                    â”‚
â”‚                                                 â”‚
â”‚ PARALLELISM                                     â”‚
â”‚ â€¢ Many workers, simultaneous                    â”‚
â”‚ â€¢ True speed gain                               â”‚
â”‚ â€¢ Uses multiple cores                           â”‚
â”‚ â€¢ Good for: Data processing, CPU work           â”‚
â”‚                                                 â”‚
â”‚ MULTI-THREADING                                 â”‚
â”‚ â€¢ One program, shared memory                    â”‚
â”‚ â€¢ Lightweight                                   â”‚
â”‚ â€¢ Complex debugging                             â”‚
â”‚ â€¢ Good for: Shared state, GUI, games            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre>
      </section>
    </main>

    <div class="progress"><div class="bar" id="bar"></div></div>
  </div>

  <script>
    (function(){
      const slides = Array.from(document.querySelectorAll('section.slide'));
      const counter = document.getElementById('counter');
      const bar = document.getElementById('bar');
      const total = slides.length;
      let idx = 0;

      function clamp(i){ return Math.max(0, Math.min(total-1, i)); }
      function show(i){
        idx = clamp(i);
        slides.forEach((s, j) => s.classList.toggle('active', j === idx));
        counter.textContent = (idx+1) + ' / ' + total;
        bar.style.width = ((idx+1) / total * 100).toFixed(2) + '%';
        const title = slides[idx].dataset.title || ('Slide ' + (idx+1));
        document.title = title + ' â€” Concurrency vs Parallelism';
        history.replaceState(null, '', '#' + (idx+1));
      }

      // Buttons
      document.getElementById('btnPrev').addEventListener('click', () => show(idx-1));
      document.getElementById('btnNext').addEventListener('click', () => show(idx+1));

      // Keyboard
      window.addEventListener('keydown', (e) => {
        const tag = (e.target.tagName || '').toLowerCase();
        if (tag === 'input' || tag === 'textarea') return;
        switch(e.key){
          case 'ArrowRight':
          case 'PageDown':
          case ' ':
            e.preventDefault(); show(idx+1); break;
          case 'ArrowLeft':
          case 'PageUp':
          case 'Backspace':
            e.preventDefault(); show(idx-1); break;
          case 'Home':
            e.preventDefault(); show(0); break;
          case 'End':
            e.preventDefault(); show(total-1); break;
        }
      });

      // Click to advance (except when selecting)
      document.getElementById('deck').addEventListener('click', (e) => {
        const sel = window.getSelection && window.getSelection().toString();
        if (sel) return; // don't advance when selecting text
        // Avoid clicks on buttons
        if ((e.target.closest && e.target.closest('.controls')) || e.target.tagName === 'BUTTON') return;
        show(idx+1);
      });

      // Touch swipe
      let touchX = null;
      window.addEventListener('touchstart', (e) => {
        touchX = e.changedTouches[0].clientX;
      }, {passive:true});
      window.addEventListener('touchend', (e) => {
        if (touchX == null) return;
        const dx = e.changedTouches[0].clientX - touchX;
        if (Math.abs(dx) > 50){
          if (dx < 0) show(idx+1); else show(idx-1);
        }
        touchX = null;
      }, {passive:true});

      // Init from hash
      const fromHash = parseInt(location.hash.replace('#',''), 10);
      if (!isNaN(fromHash)) show(fromHash-1); else show(0);
    })();
  </script>
</body>
</html>
